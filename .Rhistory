getHighFrequencyFXData<-function(var,year){
# returns an OHLC object containing the desired FX data from the desired year.
if (data=="eurusd") {
thedata<-read.csv(paste("~/R/R Projects/twap_wmfix/data/",year,"/DAT_ASCII_EURUSD_M1_",year,".csv",sep=""), sep=",", quote="\"")
}
} else {
thedata<-read.table(paste("~/R/R Projects/twap_wmfix/data/",year,"/DAT_ASCII_",toupper(var),"_M1_",year,".csv",sep=""), sep=";", quote="\"")
}
names(thedata)<-c("time_stamp","open_bid","high_bid","low_bid","close_bid","volume")
return(thedata)
}
getHighFrequencyFXData<-function(var,year){
# returns an OHLC object containing the desired FX data from the desired year.
if (data=="eurusd") {
thedata<-read.csv(paste("~/R/R Projects/twap_wmfix/data/",year,"/DAT_ASCII_EURUSD_M1_",year,".csv",sep=""), sep=",", quote="\"")
} else {
thedata<-read.table(paste("~/R/R Projects/twap_wmfix/data/",year,"/DAT_ASCII_",toupper(var),"_M1_",year,".csv",sep=""), sep=";", quote="\"")
}
names(thedata)<-c("time_stamp","open_bid","high_bid","low_bid","close_bid","volume")
return(thedata)
}
pair<-"eurusd"
training.year=c("2011")
new.year=c("2012")
train.data<-getHighFrequencyFXData(pair,training.year)
new.data<-getHighFrequencyFXData(pair,new.year)
head(train.data)
head(new.data)
pair<-"eurusd"
training.year=c("2011")
new.year=c("2012")
# If any other pair other than eurusd, use the read.table(). See twap_wmfix_getdata lines 116-127.
# At any rate, alter the next 2 lines to get the data into the workspace.
train.data<-read.csv(paste("~/R/R Projects/twap_wmfix/data/",train.year,"/DAT_ASCII_",toupper(pair),"_M1_",train.year,".csv",sep=""), sep=",", quote="\"")
new.data<-read.csv(paste("~/R/R Projects/twap_wmfix/data/",year,"/DAT_ASCII_EURUSD_M1_",year,".csv",sep=""), sep=",", quote="\"")
pair<-"eurusd"
training.year=c("2011")
new.year=c("2012")
# If any other pair other than eurusd, use the read.table(). See twap_wmfix_getdata lines 116-127.
# At any rate, alter the next 2 lines to get the data into the workspace.
train.data<-read.csv(paste("~/R/R Projects/twap_wmfix/data/",training.year,"/DAT_ASCII_",toupper(pair),"_M1_",training.year,".csv",sep=""), sep=",", quote="\"")
new.data<-read.csv(paste("~/R/R Projects/twap_wmfix/data/",year,"/DAT_ASCII_EURUSD_M1_",year,".csv",sep=""), sep=",", quote="\"")
head(train.data)
head(new.data)
pair<-"eurusd"
training.year=c("2011")
new.year=c("2012")
data.names<-c("time_stamp","open_bid","high_bid","low_bid","close_bid","volume")
# If any other pair other than eurusd, use the read.table(). See twap_wmfix_getdata lines 116-127.
# At any rate, alter the next 2 lines to get the data into the workspace.
train.data<-read.csv(paste("~/R/R Projects/twap_wmfix/data/",training.year,"/DAT_ASCII_",toupper(pair),"_M1_",training.year,".csv",sep=""), sep=",", quote="\"")
new.data<-read.csv(paste("~/R/R Projects/twap_wmfix/data/",year,"/DAT_ASCII_EURUSD_M1_",year,".csv",sep=""), sep=",", quote="\"")
names(train.data)<-data.names
names(new.data)<-data.names
head(train.data)
train.data<-read.table(read.csv(paste("~/R/R Projects/twap_wmfix/data/",training.year,"/DAT_ASCII_",toupper(pair),"_M1_",training.year,".csv",sep=""), sep=",", quote="\""))
train.data<-table(read.csv(paste("~/R/R Projects/twap_wmfix/data/",training.year,"/DAT_ASCII_",toupper(pair),"_M1_",training.year,".csv",sep=""), sep=",", quote="\"")sep=";")
train.data<-read.csv(paste("~/R/R Projects/twap_wmfix/data/",training.year,"/DAT_ASCII_",toupper(pair),"_M1_",training.year,".csv",sep=""), sep=",", quote="\""))
train.data<-read.csv(paste("~/R/R Projects/twap_wmfix/data/",training.year,"/DAT_ASCII_",toupper(pair),"_M1_",training.year,".csv",sep=""), sep=",", quote="\"")
head(train.data)
temp<-train.data
head(temp)
table(temp)
head(temp)
head(new.data)
train.data<-read.table(paste("~/R/R Projects/twap_wmfix/data/",training.year,"/DAT_ASCII_EURUSD_M1_",training.year,".csv",sep=""), sep=";", quote="\"")
head(train.data)
names(train.data)<-data.names
names(new.data)<-data.names
head(train.data)
head(new.data)
require(glmulti)
require(leaps)
require(rJava)
require(MASS)
head(eurusd.data)
makeLHS<-function(data) {
# Takes a data object and year and constructs a quantmod OHLC object which is the FIX - TWAP for that
# variable. The data should be one of the minute interval data sets in OHLC, xts format.
# The first return column = FIX - TWAP
# The second return column = TWAP 10-11am NYT
# The third return column = Fixing prices (11am NYT)
fx.time.stamps<-makeTimeStamps(data$time_stamp)
prices<-Cl(data)
fx.allt<-xts(prices,order.by=fx.time.stamps)
names(fx.allt)<-"fxrate"
fix.prices<-fx.allt[index(fx.allt,0)$hour==11 & index(fx.allt,0)$min==0] # vector of all 11am prices...
names(fix.prices)<-"fixing.rate"
hour10to11<-fx.allt[(index(fx.allt,0)$hour>=10 & index(fx.allt,0)$hour<11)] # A vector of all the prices from 10am - 11am NYT.
twap10to11<-aggregate(hour10to11$fxrate,as.Date(index(hour10to11)),mean) #THe TWAP from 10 to 11am NYT.
names(twap10to11)<-"twap"
twap10to11<-xts(twap10to11,index(fix.prices,0))
LHS<-xts((fix.prices-twap10to11),as.Date(index(fix.prices,0)))
lhs.h<-xts(rep(0,length(LHS)),index(LHS,0))
lhs.l<-xts(rep(0,length(LHS)),index(LHS,0))
lhs.c<-xts(rep(0,length(LHS)),index(LHS,0))
lhs.v<-xts(rep(0,length(LHS)),index(LHS,0))
lhs.a<-xts(rep(0,length(LHS)),index(LHS,0))
LHS<-merge.xts(LHS,twap10to11,fix.prices,lhs.c,lhs.v,lhs.a)
LHS<-as.quantmod.OHLC(LHS,
col.names = c("Open", "High",
"Low", "Close",
"Volume", "Adjusted"),
name = NULL)
return(LHS)
}
form<-as.formula(summary(train.fit)$bestmodel)
head(train.df)
require(glmulti)
require(leaps)
require(rJava)
require(MASS)
suppressWarnings(library(zoo))
suppressWarnings(library(xts))
suppressWarnings(library(quantmod))
suppressWarnings(library(PerformanceAnalytics))
suppressWarnings(library(ggplot2))
suppressWarnings(library(plyr))
suppressWarnings(library(knitr))
suppressWarnings(library(chron))
suppressWarnings(library(glmulti))
suppressWarnings(library(Quandl))
makeLHS<-function(data) {
# Takes a data object and year and constructs a quantmod OHLC object which is the FIX - TWAP for that
# variable. The data should be one of the minute interval data sets in OHLC, xts format.
# The first return column = FIX - TWAP
fx.time.stamps<-makeTimeStamps(data$time_stamp)
prices<-Cl(data)
fx.allt<-xts(prices,order.by=fx.time.stamps)
names(fx.allt)<-"fxrate"
fix.prices<-fx.allt[index(fx.allt,0)$hour==11 & index(fx.allt,0)$min==0] # vector of all 11am prices...
names(fix.prices)<-"fixing.rate"
hour10to11<-fx.allt[(index(fx.allt,0)$hour>=10 & index(fx.allt,0)$hour<11)] # A vector of all the prices from 10am - 11am NYT.
twap10to11<-aggregate(hour10to11$fxrate,as.Date(index(hour10to11)),mean) #THe TWAP from 10 to 11am NYT.
names(twap10to11)<-"twap"
twap10to11<-xts(twap10to11,index(fix.prices,0))
LHS<-xts((fix.prices-twap10to11),as.Date(index(fix.prices,0)))
lhs.h<-xts(rep(0,length(LHS)),index(LHS,0))
lhs.l<-xts(rep(0,length(LHS)),index(LHS,0))
lhs.c<-xts(rep(0,length(LHS)),index(LHS,0))
lhs.v<-xts(rep(0,length(LHS)),index(LHS,0))
lhs.a<-xts(rep(0,length(LHS)),index(LHS,0))
LHS<-merge.xts(LHS,lhs.h,lhs.l,lhs.c,lhs.v,lhs.a)
LHS<-as.quantmod.OHLC(LHS,
col.names = c("Open", "High",
"Low", "Close",
"Volume", "Adjusted"),
name = NULL)
return(LHS)
}
makeTimeStamps<-function(rawts) {
# Takes raw time stamp data from histdata.com downloads and converts it into a POSIXct format
# that we can pass to xts or other time based functions.
dates<-apply(as.matrix(rawts),MARGIN=2,FUN=substr,1,8) # character vector of extracted dates
times<-apply(as.matrix(rawts),MARGIN=2,FUN=substr,10,15) # character vector of extracted times
# Add hypen to dates...
year<-substr(dates,1,4)
month<-substr(dates,5,6)
day<-substr(dates,7,8)
hour<-substr(times,1,2)
min<-substr(times,3,4)
sec<-substr(times,5,6)
newstamps<-paste(year,"-",month,"-",day," ",hour,":",min,":",sec,sep="")
ret<-strptime(newstamps,"%Y-%m-%d %H:%M:%S")
return(ret)
}
data.source = c("yahoo")
first.date<-c("2012-01-02/") # Base date for the analysis.
year<-substr(first.date,1,4)
OHLC.indices<-c("Close") # Closing index value for the DAY...(ie. each DAY has an OHLC)
OHLC.FX<-c("Close") # Closing bid FX price for the MINUTE...(ie. each MINUTE has an OHLC)
# Function definitions should be defined here:
getData<-function(tickers,datasrc){
for (i in 1:length(tickers)){
cat(tickers[i],i,"\n")
getSymbols(tickers[i],src=datasrc,
auto.assign=getOption("getSymbols.auto.assign",TRUE),
env=parent.frame())
}
}
makeIndex<-function(x,inv,ret){
# Takes an xts object x and returns an index starting at 100 and evolving as the log returns of x.
# The inv flag tells whether or not to invert the series before calculating returns.
# The ret flag tells whether or not we have been passed a series of returns already.
init.val<-100
dts<-index(x,0)
if (inv==TRUE) data<-1/x else data<-x
if (ret==TRUE){ # we have a series of returns...
ret.series<-x
} else {
ret.series<-periodReturn(data,period="daily",subset=NULL,type="log")
dts<-index(ret.series,0)
}
n<-length(ret.series)
new.series<-ret.series
new.series[1]<-init.val
for (i in 2:n){
new.series[i]<-(1+ret.series[i-1])*new.series[i-1]
}
names(new.series)<-c("index")
return(new.series)
} # My custom index funtion for converting indices to 100 based at inception.
getOHLC<-function(assets,OHLC){
# Takes a list of assets and returns either the Open, High, Low, or Close depending
# on the passed value of HLOC. Return value is of type xts/zoo.
ret<-NULL
for (i in 1:length(assets)){
if (OHLC=="O" || OHLC=="Open"){
ret<-cbind(ret,assets[[i]][,1])
} else {
if (OHLC=="H" || OHLC=="High"){
ret<-cbind(ret,assets[[i]][,2])
} else {
if (OHLC=="L" || OHLC=="Low"){
ret<-cbind(ret,assets[[i]][,3])
} else {
if (OHLC=="C" || OHLC=="Close"){
ret<-cbind(ret,assets[[i]][,4])
}
}
}
}
}
return(ret)
}
suppressWarnings(getData(tickers.americas,data.source))
suppressWarnings(getData(tickers.asiapac,data.source))
suppressWarnings(getData(tickers.europe,data.source))
suppressWarnings(getData(tickers.africame,data.source))
suppressWarnings(getData(tickers.commod,data.source))
data.source = c("yahoo")
first.date<-c("2012-01-02/") # Base date for the analysis.
year<-substr(first.date,1,4)
OHLC.indices<-c("Close") # Closing index value for the DAY...(ie. each DAY has an OHLC)
OHLC.FX<-c("Close") # Closing bid FX price for the MINUTE...(ie. each MINUTE has an OHLC)
# Function definitions should be defined here:
getData<-function(tickers,datasrc){
for (i in 1:length(tickers)){
cat(tickers[i],i,"\n")
getSymbols(tickers[i],src=datasrc,
auto.assign=getOption("getSymbols.auto.assign",TRUE),
env=parent.frame())
}
}
makeIndex<-function(x,inv,ret){
# Takes an xts object x and returns an index starting at 100 and evolving as the log returns of x.
# The inv flag tells whether or not to invert the series before calculating returns.
# The ret flag tells whether or not we have been passed a series of returns already.
init.val<-100
dts<-index(x,0)
if (inv==TRUE) data<-1/x else data<-x
if (ret==TRUE){ # we have a series of returns...
ret.series<-x
} else {
ret.series<-periodReturn(data,period="daily",subset=NULL,type="log")
dts<-index(ret.series,0)
}
n<-length(ret.series)
new.series<-ret.series
new.series[1]<-init.val
for (i in 2:n){
new.series[i]<-(1+ret.series[i-1])*new.series[i-1]
}
names(new.series)<-c("index")
return(new.series)
} # My custom index funtion for converting indices to 100 based at inception.
getOHLC<-function(assets,OHLC){
# Takes a list of assets and returns either the Open, High, Low, or Close depending
# on the passed value of HLOC. Return value is of type xts/zoo.
ret<-NULL
for (i in 1:length(assets)){
if (OHLC=="O" || OHLC=="Open"){
ret<-cbind(ret,assets[[i]][,1])
} else {
if (OHLC=="H" || OHLC=="High"){
ret<-cbind(ret,assets[[i]][,2])
} else {
if (OHLC=="L" || OHLC=="Low"){
ret<-cbind(ret,assets[[i]][,3])
} else {
if (OHLC=="C" || OHLC=="Close"){
ret<-cbind(ret,assets[[i]][,4])
}
}
}
}
}
return(ret)
}
# Make symbol collection...
tickers.americas=c("^MERV","^BVSP","^GSPTSE","^IPC","^GSPC","DOW")
tickers.asiapac=c("^AORD","^SSEC","^HSI","^BSESN","^JKSE","^KLSE","^N225","^NZ50","^STI","^KS11","^TWII")
tickers.europe=c("^ATX","^BFX","^FCHI","^GDAXI","^AEX","^OSEAX","^OMXSPI","^SSMI","^FTSE",
"^MCX","GD.AT")
tickers.africame=c("^TA100")
tickers.commod=c("DJC")
labels.americas=c("Merval","Bovespa","SP.TSX.Comp","MXX","SP500","Dow")
labels.asiapac=c("All Ordinaries","Shanghai Comp","Hang Seng","BSE30","Jakarta Comp",
"KLSE Comp","Nikkei 225","NZSE50 Index","Straits Times Index","KOSPI Index",
"Taiwan Weighted")
labels.europe=c("ATX Index","BEL20 Index","CAC40 Index","DAX Index","AEX General","OSE All Share",
"Stockholm General","Swiss Market","FTSE 100","MICEX Index","Athex Composite")
labels.africame=c("TA 100")
labesl.commod=c("DJ-UBS Comm. Index")
suppressWarnings(getData(tickers.americas,data.source))
suppressWarnings(getData(tickers.asiapac,data.source))
suppressWarnings(getData(tickers.europe,data.source))
suppressWarnings(getData(tickers.africame,data.source))
suppressWarnings(getData(tickers.commod,data.source))
suppressWarnings(library(quantmod))
require(quantmod)
data.source = c("yahoo")
first.date<-c("2012-01-02/") # Base date for the analysis.
year<-substr(first.date,1,4)
OHLC.indices<-c("Close") # Closing index value for the DAY...(ie. each DAY has an OHLC)
OHLC.FX<-c("Close") # Closing bid FX price for the MINUTE...(ie. each MINUTE has an OHLC)
# Function definitions should be defined here:
getData<-function(tickers,datasrc){
for (i in 1:length(tickers)){
cat(tickers[i],i,"\n")
getSymbols(tickers[i],src=datasrc,
auto.assign=getOption("getSymbols.auto.assign",TRUE),
env=parent.frame())
}
}
makeIndex<-function(x,inv,ret){
# Takes an xts object x and returns an index starting at 100 and evolving as the log returns of x.
# The inv flag tells whether or not to invert the series before calculating returns.
# The ret flag tells whether or not we have been passed a series of returns already.
init.val<-100
dts<-index(x,0)
if (inv==TRUE) data<-1/x else data<-x
if (ret==TRUE){ # we have a series of returns...
ret.series<-x
} else {
ret.series<-periodReturn(data,period="daily",subset=NULL,type="log")
dts<-index(ret.series,0)
}
n<-length(ret.series)
new.series<-ret.series
new.series[1]<-init.val
for (i in 2:n){
new.series[i]<-(1+ret.series[i-1])*new.series[i-1]
}
names(new.series)<-c("index")
return(new.series)
} # My custom index funtion for converting indices to 100 based at inception.
getOHLC<-function(assets,OHLC){
# Takes a list of assets and returns either the Open, High, Low, or Close depending
# on the passed value of HLOC. Return value is of type xts/zoo.
ret<-NULL
for (i in 1:length(assets)){
if (OHLC=="O" || OHLC=="Open"){
ret<-cbind(ret,assets[[i]][,1])
} else {
if (OHLC=="H" || OHLC=="High"){
ret<-cbind(ret,assets[[i]][,2])
} else {
if (OHLC=="L" || OHLC=="Low"){
ret<-cbind(ret,assets[[i]][,3])
} else {
if (OHLC=="C" || OHLC=="Close"){
ret<-cbind(ret,assets[[i]][,4])
}
}
}
}
}
return(ret)
}
tickers.americas=c("^MERV","^BVSP","^GSPTSE","^IPC","^GSPC","DOW")
tickers.asiapac=c("^AORD","^SSEC","^HSI","^BSESN","^JKSE","^KLSE","^N225","^NZ50","^STI","^KS11","^TWII")
tickers.europe=c("^ATX","^BFX","^FCHI","^GDAXI","^AEX","^OSEAX","^OMXSPI","^SSMI","^FTSE",
"^MCX","GD.AT")
tickers.africame=c("^TA100")
tickers.commod=c("DJC")
labels.americas=c("Merval","Bovespa","SP.TSX.Comp","MXX","SP500","Dow")
labels.asiapac=c("All Ordinaries","Shanghai Comp","Hang Seng","BSE30","Jakarta Comp",
"KLSE Comp","Nikkei 225","NZSE50 Index","Straits Times Index","KOSPI Index",
"Taiwan Weighted")
labels.europe=c("ATX Index","BEL20 Index","CAC40 Index","DAX Index","AEX General","OSE All Share",
"Stockholm General","Swiss Market","FTSE 100","MICEX Index","Athex Composite")
labels.africame=c("TA 100")
labesl.commod=c("DJ-UBS Comm. Index")
suppressWarnings(getData(tickers.americas,data.source))
suppressWarnings(getData(tickers.asiapac,data.source))
suppressWarnings(getData(tickers.europe,data.source))
suppressWarnings(getData(tickers.africame,data.source))
suppressWarnings(getData(tickers.commod,data.source))
head(MERV)
head(IPC)
makeLHS<-function(data) {
# Takes a data object and year and constructs a quantmod OHLC object which is the FIX - TWAP for that
# variable. The data should be one of the minute interval data sets in OHLC, xts format.
# The first return column = FIX - TWAP
fx.time.stamps<-makeTimeStamps(data$time_stamp)
prices<-Cl(data)
fx.allt<-xts(prices,order.by=fx.time.stamps)
names(fx.allt)<-"fxrate"
fix.prices<-fx.allt[index(fx.allt,0)$hour==11 & index(fx.allt,0)$min==0] # vector of all 11am prices...
names(fix.prices)<-"fixing.rate"
hour10to11<-fx.allt[(index(fx.allt,0)$hour>=10 & index(fx.allt,0)$hour<11)] # A vector of all the prices from 10am - 11am NYT.
twap10to11<-aggregate(hour10to11$fxrate,as.Date(index(hour10to11)),mean) #THe TWAP from 10 to 11am NYT.
names(twap10to11)<-"twap"
twap10to11<-xts(twap10to11,index(fix.prices,0))
LHS<-xts((fix.prices-twap10to11),as.Date(index(fix.prices,0)))
lhs.h<-xts(rep(0,length(LHS)),index(LHS,0))
lhs.l<-xts(rep(0,length(LHS)),index(LHS,0))
lhs.c<-xts(rep(0,length(LHS)),index(LHS,0))
lhs.v<-xts(rep(0,length(LHS)),index(LHS,0))
lhs.a<-xts(rep(0,length(LHS)),index(LHS,0))
LHS<-merge.xts(LHS,lhs.h,lhs.l,lhs.c,lhs.v,lhs.a)
LHS<-as.quantmod.OHLC(LHS,
col.names = c("Open", "High",
"Low", "Close",
"Volume", "Adjusted"),
name = NULL)
return(LHS)
}
pair<-"eurusd"
training.year=c("2011")
new.year=c("2012")
data.names<-c("time_stamp","open_bid","high_bid","low_bid","close_bid","volume")
# If any other pair other than eurusd, use the read.table(). See twap_wmfix_getdata lines 116-127.
# At any rate, alter the next 2 lines to get the data into the workspace.
train.data<-read.table(paste("~/R/R Projects/twap_wmfix/data/",training.year,"/DAT_ASCII_EURUSD_M1_",training.year,".csv",sep=""), sep=";", quote="\"")
new.data<-read.csv(paste("~/R/R Projects/twap_wmfix/data/",year,"/DAT_ASCII_EURUSD_M1_",year,".csv",sep=""), sep=",", quote="\"")
names(train.data)<-data.names
names(new.data)<-data.names
first.train.date<-c("2011-01-03/")
first.new.date<-c("2012-01-02/")
head(train.data)
head(new.data)
head(train.df)
head(train.data)
head(train.df)
train.LHS<-makeLHS(train.data)
head(MERV)
makeTimeStamps<-function(rawts) {
# Takes raw time stamp data from histdata.com downloads and converts it into a POSIXct format
# that we can pass to xts or other time based functions.
dates<-apply(as.matrix(rawts),MARGIN=2,FUN=substr,1,8) # character vector of extracted dates
times<-apply(as.matrix(rawts),MARGIN=2,FUN=substr,10,15) # character vector of extracted times
# Add hypen to dates...
year<-substr(dates,1,4)
month<-substr(dates,5,6)
day<-substr(dates,7,8)
hour<-substr(times,1,2)
min<-substr(times,3,4)
sec<-substr(times,5,6)
newstamps<-paste(year,"-",month,"-",day," ",hour,":",min,":",sec,sep="")
ret<-strptime(newstamps,"%Y-%m-%d %H:%M:%S")
return(ret)
}
makeLHS<-function(data) {
# Takes a data object and year and constructs a quantmod OHLC object which is the FIX - TWAP for that
# variable. The data should be one of the minute interval data sets in OHLC, xts format.
# The first return column = FIX - TWAP
fx.time.stamps<-makeTimeStamps(data$time_stamp)
prices<-Cl(data)
fx.allt<-xts(prices,order.by=fx.time.stamps)
names(fx.allt)<-"fxrate"
fix.prices<-fx.allt[index(fx.allt,0)$hour==11 & index(fx.allt,0)$min==0] # vector of all 11am prices...
names(fix.prices)<-"fixing.rate"
hour10to11<-fx.allt[(index(fx.allt,0)$hour>=10 & index(fx.allt,0)$hour<11)] # A vector of all the prices from 10am - 11am NYT.
twap10to11<-aggregate(hour10to11$fxrate,as.Date(index(hour10to11)),mean) #THe TWAP from 10 to 11am NYT.
names(twap10to11)<-"twap"
twap10to11<-xts(twap10to11,index(fix.prices,0))
LHS<-xts((fix.prices-twap10to11),as.Date(index(fix.prices,0)))
lhs.h<-xts(rep(0,length(LHS)),index(LHS,0))
lhs.l<-xts(rep(0,length(LHS)),index(LHS,0))
lhs.c<-xts(rep(0,length(LHS)),index(LHS,0))
lhs.v<-xts(rep(0,length(LHS)),index(LHS,0))
lhs.a<-xts(rep(0,length(LHS)),index(LHS,0))
LHS<-merge.xts(LHS,lhs.h,lhs.l,lhs.c,lhs.v,lhs.a)
LHS<-as.quantmod.OHLC(LHS,
col.names = c("Open", "High",
"Low", "Close",
"Volume", "Adjusted"),
name = NULL)
return(LHS)
}
require(glmulti)
require(leaps)
require(rJava)
require(MASS)
suppressWarnings(library(zoo))
suppressWarnings(library(xts))
suppressWarnings(library(quantmod))
suppressWarnings(library(PerformanceAnalytics))
suppressWarnings(library(ggplot2))
suppressWarnings(library(plyr))
suppressWarnings(library(knitr))
suppressWarnings(library(chron))
suppressWarnings(library(glmulti))
suppressWarnings(library(Quandl))
pair<-"eurusd"
training.year=c("2011")
new.year=c("2012")
data.names<-c("time_stamp","open_bid","high_bid","low_bid","close_bid","volume")
# If any other pair other than eurusd, use the read.table(). See twap_wmfix_getdata lines 116-127.
# At any rate, alter the next 2 lines to get the data into the workspace.
train.data<-read.table(paste("~/R/R Projects/twap_wmfix/data/",training.year,"/DAT_ASCII_EURUSD_M1_",training.year,".csv",sep=""), sep=";", quote="\"")
new.data<-read.csv(paste("~/R/R Projects/twap_wmfix/data/",year,"/DAT_ASCII_EURUSD_M1_",year,".csv",sep=""), sep=",", quote="\"")
names(train.data)<-data.names
names(new.data)<-data.names
first.train.date<-c("2011-01-03/")
first.new.date<-c("2012-01-02/")
head(train.data)
head(new.data)
train.LHS<-makeLHS(train.data)
head(train.LHS)
