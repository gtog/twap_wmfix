lenght(t4)
length(t4)
names(t4)<-"fixing.rate"
head(t4)
hour10to11<-t3[(index(t3,0)$hour>=10 & index(t3,0)$hour<11)]
head(hour10to11
)
length(hour10to11)
259*60
15549/60
rm(hour10to11)
head(t4)
head(t3)
t5<-t3[(index(t3,0)$hour>=10 & index(t3,0)$hour<11)]
t6<-aggregate(t5$fxrate,as.Date(index(t5)),mean)
head(t6)
length(t6)
length(t3)
length(t4)
names(t6)<-"twap")
names(t6)<-"twap"
head(t6)
head(t4)
tail(t4)
tail(t6)
length(t4,t6)
length(t4)
length(t6)
length(t3)
length(t4)
length(t4)
xts(t6,index(t4,0))
new.year=c("2009")
new.data<-read.csv(paste("~/R/R Projects/twap_wmfix/data/",new.year,"/DAT_ASCII_EURUSD_M1_",new.year,".csv",sep=""), sep=";", quote="\"")
names(new.data)<-data.names
first.new.date<-c("2009-01-02/")
head(train.data)
head(new.data)
new.LHS<-makeLHS(new.data)
new.df<-na.omit(merge.xts(Op(new.LHS),OpCl(IPC[first.new.date]),join="left"))
names(new.df)<-c("LHS.Open","OpCl.IPC")
new.df<-merge.xts(new.df,OpCl(DOW),join="inner")
new.df<-merge.xts(new.df,OpCl(BSESN),join="inner")
new.df<-merge.xts(new.df,OpCl(GDAXI),join="inner")
new.df<-merge.xts(new.df,OpCl(SSMI),join="inner")
new.df<-merge.xts(new.df,OpCl(TA100),join="inner")
new.df<-merge.xts(new.df,na.omit(Return.calculate(DEXUSAL)),join="inner") # AUDUSD
new.df<-merge.xts(new.df,na.omit(Return.calculate(DEXINUS)),join="inner") # USDINR
new.df<-merge.xts(new.df,na.omit(Return.calculate(DEXBZUS)),join="inner") # USDBRL
new.df<-merge.xts(new.df,na.omit(Return.calculate(DEXCAUS)),join="inner") # USDCAD
new.df<-merge.xts(new.df,na.omit(Return.calculate(DEXUSEU)),join="inner") # EURUSD
new.df<-merge.xts(new.df,na.omit(Return.calculate(DEXJPUS)),join="inner") # USDJPY
new.df<-merge.xts(new.df,na.omit(Return.calculate(DEXMXUS)),join="inner") # USDMXN
new.df<-merge.xts(new.df,na.omit(Return.calculate(DEXKOUS)),join="inner") # USDKRW
head(new.df)
new.model<-lm(train.form,data=new.df)
summary(new.model)
new.actuals<-as.vector(new.df$LHS.Open)
new.fitted<-as.vector(fitted(new.model))
plot(new.actuals,type="l",col="dark grey")
lines(new.fitted,col="blue")
plot(residuals(new.model),type="l",col="red")
plot(density(residuals(new.model)))
train.signal.perf<-sign(train.fitted)*sign(train.actuals)
plot(density(train.signal.perf),type="l",col="red")
count(train.signal.perf<0)
47/(158+47)
new.year=c("2012")
new.data<-read.csv(paste("~/R/R Projects/twap_wmfix/data/",new.year,"/DAT_ASCII_EURUSD_M1_",new.year,".csv",sep=""), sep=";", quote="\"")
names(new.data)<-data.names
first.new.date<-c("2012-01-02/")
new.year=c("2012")
new.data<-read.csv(paste("~/R/R Projects/twap_wmfix/data/",new.year,"/DAT_ASCII_EURUSD_M1_",new.year,".csv",sep=""), sep=",", quote="\"")
names(new.data)<-data.names
first.new.date<-c("2012-01-02/")
head(train.data)
head(new.data)
head(train.df)
train.form<-as.formula(summary(train.fit)$bestmodel)
train.model<-lm(train.form,data=train.df)
summary(train.model)
train.actuals<-as.vector(train.df$LHS.Open)
train.fitted<-as.vector(fitted(train.model))
plot(train.actuals,type="l",col="dark grey")
lines(train.fitted,col="blue")
plot(residuals(train.model),type="l",col="red")
train.signal.perf<-sign(train.fitted)*sign(train.actuals)
plot(density(train.signal.perf),type="l",col="red")
count(train.signal.perf<0)
47/(158+47)
new.LHS<-makeLHS(new.data) # The new response variable...
new.df<-na.omit(merge.xts(Op(new.LHS),OpCl(IPC[first.new.date]),join="left"))
names(new.df)<-c("LHS.Open","OpCl.IPC")
new.df<-merge.xts(new.df,OpCl(DOW),join="inner")
new.df<-merge.xts(new.df,OpCl(BSESN),join="inner")
new.df<-merge.xts(new.df,OpCl(GDAXI),join="inner")
new.df<-merge.xts(new.df,OpCl(SSMI),join="inner")
new.df<-merge.xts(new.df,OpCl(TA100),join="inner")
new.df<-merge.xts(new.df,na.omit(Return.calculate(DEXUSAL)),join="inner") # AUDUSD
new.df<-merge.xts(new.df,na.omit(Return.calculate(DEXINUS)),join="inner") # USDINR
new.df<-merge.xts(new.df,na.omit(Return.calculate(DEXBZUS)),join="inner") # USDBRL
new.df<-merge.xts(new.df,na.omit(Return.calculate(DEXCAUS)),join="inner") # USDCAD
new.df<-merge.xts(new.df,na.omit(Return.calculate(DEXUSEU)),join="inner") # EURUSD
new.df<-merge.xts(new.df,na.omit(Return.calculate(DEXJPUS)),join="inner") # USDJPY
new.df<-merge.xts(new.df,na.omit(Return.calculate(DEXMXUS)),join="inner") # USDMXN
new.df<-merge.xts(new.df,na.omit(Return.calculate(DEXKOUS)),join="inner") # USDKRW
head(new.df)
summary(new.model)
new.actuals<-as.vector(new.df$LHS.Open)
new.fitted<-as.vector(fitted(new.model))
plot(new.actuals,type="l",col="dark grey")
lines(new.fitted,col="blue")
plot(residuals(new.model),type="l",col="red")
new.signal.perf<-sign(new.fitted)*sign(new.actuals)
plot(density(new.signal.perf),type="l",col="red",ylim=c(0,1.3))
lines(density(train.signal.perf),type="l",col="dark grey")
count(new.signal.perf<0)
new.year=c("2012")
new.data<-read.csv(paste("~/R/R Projects/twap_wmfix/data/",new.year,"/DAT_ASCII_EURUSD_M1_",new.year,".csv",sep=""), sep=",", quote="\"")
names(new.data)<-data.names
first.new.date<-c("2012-01-02/")
head(train.data)
head(new.data)
new.LHS<-makeLHS(new.data)
head
(new.LHS)
summary(new.LHS)
summary(train.LHS)
plot(new.LHS$LHS.Open,type="l",col="red")
lines(train.LHS$LHS.Open,type="l",col="blue")
head(train.LHS)
length(train.LHS$LHS.Open)
plot(train.LHS$LHS.Open,type="l",col="blue")
lines(new.LHS$LHS.Open,type="l",col="red")
head(new.LHS)
tail(new.LHS)
head(train.LHS)
tail(train.LHS)
new.model<-lm(train.form,data=new.df)
summary(new.model)
new.actuals<-as.vector(new.df$LHS.Open)
new.fitted<-as.vector(fitted(new.model))
plot(new.actuals,type="l",col="dark grey")
lines(new.fitted,col="blue")
new.signal.perf<-sign(new.fitted)*sign(new.actuals)
plot(density(new.signal.perf),type="l",col="red",ylim=c(0,1.3))
lines(density(train.signal.perf),type="l",col="dark grey")
count(new.signal.perf<0)
require(glmulti)
require(leaps)
require(rJava)
require(MASS)
suppressWarnings(library(zoo))
suppressWarnings(library(xts))
suppressWarnings(library(quantmod))
suppressWarnings(library(PerformanceAnalytics))
suppressWarnings(library(ggplot2))
suppressWarnings(library(plyr))
suppressWarnings(library(knitr))
suppressWarnings(library(chron))
suppressWarnings(library(glmulti))
suppressWarnings(library(Quandl))
new.year=c("2010")
new.data<-read.csv(paste("~/R/R Projects/twap_wmfix/data/",new.year,"/DAT_ASCII_EURUSD_M1_",new.year,".csv",sep=""), sep=",", quote="\"")
names(new.data)<-data.names
first.new.date<-c("2010-01-02/")
new.year=c("2010")
new.data<-read.csv(paste("~/R/R Projects/twap_wmfix/data/",new.year,"/DAT_ASCII_EURUSD_M1_",new.year,".csv",sep=""), sep=";", quote="\"")
names(new.data)<-data.names
first.new.date<-c("2010-01-02/")
head(train.data)
head(new.data)
new.LHS<-makeLHS(new.data) # The new response variable...
head(t1)
head(t4)
t8<-merge.xts(t4,t6,join="inner")
head(t8)
head(t4)
head(t4)
head(t6)
class(t6)
length(t4)
length(t6)
head(t4)
head(t6)
head(t5)
head(t6)
makeLHS<-function(data) {
# Takes a data object and year and constructs a quantmod OHLC object which is the FIX - TWAP for that
# variable. The data should be one of the minute interval data sets in OHLC, xts format.
# The first return column = FIX - TWAP
fx.time.stamps<-makeTimeStamps(data$time_stamp)
prices<-Cl(data)
fx.allt<-xts(prices,order.by=fx.time.stamps)
names(fx.allt)<-"fxrate"
fix.prices<-fx.allt[index(fx.allt,0)$hour==11 & index(fx.allt,0)$min==0] # vector of all 11am prices...
names(fix.prices)<-"fixing.rate"
hour10to11<-fx.allt[(index(fx.allt,0)$hour>=10 & index(fx.allt,0)$hour<11)] # A vector of all the prices from 10am - 11am NYT.
twap10to11<-aggregate(hour10to11$fxrate,as.Date(index(hour10to11)),mean) #THe TWAP from 10 to 11am NYT.
names(twap10to11)<-"twap"
#twap10to11<-xts(twap10to11,index(fix.prices,0))
LHS<-xts((fix.prices-twap10to11),as.Date(index(fix.prices,0)))
lhs.h<-xts(rep(0,length(LHS)),index(LHS,0))
lhs.l<-xts(rep(0,length(LHS)),index(LHS,0))
lhs.c<-xts(rep(0,length(LHS)),index(LHS,0))
lhs.v<-xts(rep(0,length(LHS)),index(LHS,0))
lhs.a<-xts(rep(0,length(LHS)),index(LHS,0))
LHS<-merge.xts(LHS,lhs.h,lhs.l,lhs.c,lhs.v,lhs.a)
LHS<-as.quantmod.OHLC(LHS,
col.names = c("Open", "High",
"Low", "Close",
"Volume", "Adjusted"),
name = NULL)
return(LHS)
}
new.LHS<-makeLHS(new.data)
makeLHS<-function(data) {
# Takes a data object and year and constructs a quantmod OHLC object which is the FIX - TWAP for that
# variable. The data should be one of the minute interval data sets in OHLC, xts format.
# The first return column = FIX - TWAP
fx.time.stamps<-makeTimeStamps(data$time_stamp)
prices<-Cl(data)
fx.allt<-xts(prices,order.by=fx.time.stamps)
names(fx.allt)<-"fxrate"
fix.prices<-fx.allt[index(fx.allt,0)$hour==11 & index(fx.allt,0)$min==0] # vector of all 11am prices...
names(fix.prices)<-"fixing.rate"
hour10to11<-fx.allt[(index(fx.allt,0)$hour>=10 & index(fx.allt,0)$hour<11)] # A vector of all the prices from 10am - 11am NYT.
twap10to11<-aggregate(hour10to11$fxrate,as.Date(index(hour10to11)),mean) #THe TWAP from 10 to 11am NYT.
names(twap10to11)<-"twap"
twap10to11<-as.xts(twap10to11)#,index(fix.prices,0))
LHS<-xts((fix.prices-twap10to11),as.Date(index(fix.prices,0)))
lhs.h<-xts(rep(0,length(LHS)),index(LHS,0))
lhs.l<-xts(rep(0,length(LHS)),index(LHS,0))
lhs.c<-xts(rep(0,length(LHS)),index(LHS,0))
lhs.v<-xts(rep(0,length(LHS)),index(LHS,0))
lhs.a<-xts(rep(0,length(LHS)),index(LHS,0))
LHS<-merge.xts(LHS,lhs.h,lhs.l,lhs.c,lhs.v,lhs.a)
LHS<-as.quantmod.OHLC(LHS,
col.names = c("Open", "High",
"Low", "Close",
"Volume", "Adjusted"),
name = NULL)
return(LHS)
}
new.LHS<-makeLHS(new.data)
makeLHS<-function(data) {
# Takes a data object and year and constructs a quantmod OHLC object which is the FIX - TWAP for that
# variable. The data should be one of the minute interval data sets in OHLC, xts format.
# The first return column = FIX - TWAP
fx.time.stamps<-makeTimeStamps(data$time_stamp)
prices<-Cl(data)
fx.allt<-xts(prices,order.by=fx.time.stamps)
names(fx.allt)<-"fxrate"
fix.prices<-fx.allt[index(fx.allt,0)$hour==11 & index(fx.allt,0)$min==0] # vector of all 11am prices...
names(fix.prices)<-"fixing.rate"
hour10to11<-fx.allt[(index(fx.allt,0)$hour>=10 & index(fx.allt,0)$hour<=11)] # A vector of all the prices from 10am - 11am NYT.
twap10to11<-aggregate(hour10to11$fxrate,as.Date(index(hour10to11)),mean) #THe TWAP from 10 to 11am NYT.
names(twap10to11)<-"twap"
twap10to11<-xts(twap10to11,index(fix.prices,0))
LHS<-xts((fix.prices-twap10to11),as.Date(index(fix.prices,0)))
lhs.h<-xts(rep(0,length(LHS)),index(LHS,0))
lhs.l<-xts(rep(0,length(LHS)),index(LHS,0))
lhs.c<-xts(rep(0,length(LHS)),index(LHS,0))
lhs.v<-xts(rep(0,length(LHS)),index(LHS,0))
lhs.a<-xts(rep(0,length(LHS)),index(LHS,0))
LHS<-merge.xts(LHS,lhs.h,lhs.l,lhs.c,lhs.v,lhs.a)
LHS<-as.quantmod.OHLC(LHS,
col.names = c("Open", "High",
"Low", "Close",
"Volume", "Adjusted"),
name = NULL)
return(LHS)
}
new.LHS<-makeLHS(new.data)
makeLHS<-function(data) {
# Takes a data object and year and constructs a quantmod OHLC object which is the FIX - TWAP for that
# variable. The data should be one of the minute interval data sets in OHLC, xts format.
# The first return column = FIX - TWAP
fx.time.stamps<-makeTimeStamps(data$time_stamp)
prices<-Cl(data)
fx.allt<-xts(prices,order.by=fx.time.stamps)
names(fx.allt)<-"fxrate"
fix.prices<-fx.allt[index(fx.allt,0)$hour==11 & index(fx.allt,0)$min==0] # vector of all 11am prices...
names(fix.prices)<-"fixing.rate"
hour10to11<-fx.allt[(index(fx.allt,0)$hour>=10 & index(fx.allt,0)$hour<11)] # A vector of all the prices from 10am - 11am NYT.
twap10to11<-aggregate(hour10to11$fxrate,as.Date(index(hour10to11)),mean) #THe TWAP from 10 to 11am NYT.
names(twap10to11)<-"twap"
twap10to11<-xts(twap10to11,index(fix.prices,0))
LHS<-xts((fix.prices-twap10to11),as.Date(index(fix.prices,0)))
lhs.h<-xts(rep(0,length(LHS)),index(LHS,0))
lhs.l<-xts(rep(0,length(LHS)),index(LHS,0))
lhs.c<-xts(rep(0,length(LHS)),index(LHS,0))
lhs.v<-xts(rep(0,length(LHS)),index(LHS,0))
lhs.a<-xts(rep(0,length(LHS)),index(LHS,0))
LHS<-merge.xts(LHS,lhs.h,lhs.l,lhs.c,lhs.v,lhs.a)
LHS<-as.quantmod.OHLC(LHS,
col.names = c("Open", "High",
"Low", "Close",
"Volume", "Adjusted"),
name = NULL)
return(LHS)
}
data=new.data
fx.time.stamps<-makeTimeStamps(data$time_stamp)
head(fx.time.stamps)
length(fx.time.stamps)
prices<-Cl(data)
head(prices)
length(prices)
fx.allt<-xts(prices,order.by=fx.time.stamps)
names(fx.allt)<-"fxrate"
head(fx.allt)
length(fx.allt)
fix.prices<-fx.allt[index(fx.allt,0)$hour==11 & index(fx.allt,0)$min==0]
head(fix.prices)
length(fix.prices)
head(fx.allt)
hour10to11<-fx.allt[(index(fx.allt,0)$hour>=10 & index(fx.allt,0)$hour<11)]
length(hour10to11)
head(hour10to11)
twap10to11<-aggregate(hour10to11$fxrate,as.Date(index(hour10to11,0)),mean)
head(twap10to11)
length(twap10to11)
head(hour10to11)
length(hour)
length(hour10to11)
head(fix.prices)
head(twap10to11)
tail(fix.prices)
tail(twap10to11)
head(hour10to11)
head(fix.prices)
head(twap)
head(twap10to11)
?merge
merge.xts
?merge/xts
?merge.xts
head(hour)
head(hour10to11)
head(twap10to11)
length(as.Date(index(hour10to11,0)))
temp<-as.Date(index(hour10to11,0))
length(temp)
head(temp)
aggregate(temp)
aggregate(temp,unique)
?aggregate
head(fix.prices)
fix.datea<-as.Date(index(fix.prices,0))
head(fix.datea)
rm(fix.datea)
makeLHS<-function(data) {
# Takes a data object and year and constructs a quantmod OHLC object which is the FIX - TWAP for that
# variable. The data should be one of the minute interval data sets in OHLC, xts format.
# The first return column = FIX - TWAP
fx.time.stamps<-makeTimeStamps(data$time_stamp)
prices<-Cl(data)
fx.allt<-xts(prices,order.by=fx.time.stamps)
names(fx.allt)<-"fxrate"
fix.prices<-fx.allt[index(fx.allt,0)$hour==11 & index(fx.allt,0)$min==0] # vector of all 11am prices...
names(fix.prices)<-"fixing.rate"
hour10to11<-fx.allt[(index(fx.allt,0)$hour>=10 & index(fx.allt,0)$hour<11)] # A vector of all the prices from 10am - 11am NYT.
twap10to11<-aggregate(hour10to11$fxrate,as.Date(index(hour10to11,0)),mean) # THe TWAP from 10 to 11am NYT.
names(twap10to11)<-"twap"
twap10to11<-xts(twap10to11,as.Date(index(hour10to11,0))
LHS<-xts((fix.prices-twap10to11),as.Date(index(fix.prices,0)))
lhs.h<-xts(rep(0,length(LHS)),index(LHS,0))
lhs.l<-xts(rep(0,length(LHS)),index(LHS,0))
lhs.c<-xts(rep(0,length(LHS)),index(LHS,0))
lhs.v<-xts(rep(0,length(LHS)),index(LHS,0))
lhs.a<-xts(rep(0,length(LHS)),index(LHS,0))
LHS<-merge.xts(LHS,lhs.h,lhs.l,lhs.c,lhs.v,lhs.a)
LHS<-as.quantmod.OHLC(LHS,
col.names = c("Open", "High",
"Low", "Close",
"Volume", "Adjusted"),
name = NULL)
return(LHS)
}
makeLHS<-function(data) {
# Takes a data object and year and constructs a quantmod OHLC object which is the FIX - TWAP for that
# variable. The data should be one of the minute interval data sets in OHLC, xts format.
# The first return column = FIX - TWAP
fx.time.stamps<-makeTimeStamps(data$time_stamp)
prices<-Cl(data)
fx.allt<-xts(prices,order.by=fx.time.stamps)
names(fx.allt)<-"fxrate"
fix.prices<-fx.allt[index(fx.allt,0)$hour==11 & index(fx.allt,0)$min==0] # vector of all 11am prices...
names(fix.prices)<-"fixing.rate"
hour10to11<-fx.allt[(index(fx.allt,0)$hour>=10 & index(fx.allt,0)$hour<11)] # A vector of all the prices from 10am - 11am NYT.
twap10to11<-aggregate(hour10to11$fxrate,as.Date(index(hour10to11,0)),mean) # THe TWAP from 10 to 11am NYT.
names(twap10to11)<-"twap"
twap10to11<-xts(twap10to11,as.Date(index(hour10to11,0)))
LHS<-xts((fix.prices-twap10to11),as.Date(index(fix.prices,0)))
lhs.h<-xts(rep(0,length(LHS)),index(LHS,0))
lhs.l<-xts(rep(0,length(LHS)),index(LHS,0))
lhs.c<-xts(rep(0,length(LHS)),index(LHS,0))
lhs.v<-xts(rep(0,length(LHS)),index(LHS,0))
lhs.a<-xts(rep(0,length(LHS)),index(LHS,0))
LHS<-merge.xts(LHS,lhs.h,lhs.l,lhs.c,lhs.v,lhs.a)
LHS<-as.quantmod.OHLC(LHS,
col.names = c("Open", "High",
"Low", "Close",
"Volume", "Adjusted"),
name = NULL)
return(LHS)
}
new.LHS<-makeLHS(new.data)
twap10to11<-aggregate(hour10to11$fxrate,as.Date(index(hour10to11,0)),mean)
length(twap)
length(twap10to11)
head(twap10to11
)
head(fix.prices)
fix.dates<-as.Date(index(fix.prices,0))
head(fix.dates)
length(fix.dates)
fix.prices<-xts(fix.prices,fix.dates)
temp<-merge.xts(fix.prices,twap10to11,join="inner")
head(temp)
class(temp)
LHS<-temp$fix.prices-temp$twap10to11
head(temp)
fx.time.stamps<-makeTimeStamps(data$time_stamp)
prices<-Cl(data)
fx.allt<-xts(prices,order.by=fx.time.stamps)
names(fx.allt)<-"fxrate"
fix.prices<-fx.allt[index(fx.allt,0)$hour==11 & index(fx.allt,0)$min==0] # vector of all 11am prices...
fix.dates<-as.Date(index(fix.prices,0))
fix.prices<-xts(fix.prices,fix.dates)
names(fix.prices)<-"fixing.rate"
hour10to11<-fx.allt[(index(fx.allt,0)$hour>=10 & index(fx.allt,0)$hour<11)] # A vector of all the prices from 10am - 11am NYT.
twap10to11<-aggregate(hour10to11$fxrate,as.Date(index(hour10to11,0)),mean) # THe TWAP from 10 to 11am NYT.
names(twap10to11)<-"twap"
head(fix.prices)
temp<-merge.xts(fix.prices,twap10to11,join="inner")
head(temp)
LHS<-temp$fixing.rate-temp$twap
lhs.h<-xts(rep(0,length(LHS)),index(LHS,0))
lhs.l<-xts(rep(0,length(LHS)),index(LHS,0))
lhs.c<-xts(rep(0,length(LHS)),index(LHS,0))
lhs.v<-xts(rep(0,length(LHS)),index(LHS,0))
lhs.a<-xts(rep(0,length(LHS)),index(LHS,0))
LHS<-merge.xts(LHS,lhs.h,lhs.l,lhs.c,lhs.v,lhs.a)
LHS<-as.quantmod.OHLC(LHS,
col.names = c("Open", "High",
"Low", "Close",
"Volume", "Adjusted"),
name = NULL)
head(LHS)
rm(fx.time.stamps,prices,fx.allt,fix.prices,fix.dates,fix.prices,hour10to11,twap10to11,temp,LHS,lhs.h,lhs.l,lhs.c,lhs.v,lhs.a)
rm(t1,t2,t3,t4,t5,t6,t8)
makeLHS<-function(data) {
# Takes a data object and year and constructs a quantmod OHLC object which is the FIX - TWAP for that
# variable. The data should be one of the minute interval data sets in OHLC, xts format.
# The first return column = FIX - TWAP
fx.time.stamps<-makeTimeStamps(data$time_stamp)
prices<-Cl(data)
fx.allt<-xts(prices,order.by=fx.time.stamps)
names(fx.allt)<-"fxrate"
fix.prices<-fx.allt[index(fx.allt,0)$hour==11 & index(fx.allt,0)$min==0] # vector of all 11am prices...
fix.dates<-as.Date(index(fix.prices,0))
fix.prices<-xts(fix.prices,fix.dates)
names(fix.prices)<-"fixing.rate"
hour10to11<-fx.allt[(index(fx.allt,0)$hour>=10 & index(fx.allt,0)$hour<11)] # A vector of all the prices from 10am - 11am NYT.
twap10to11<-aggregate(hour10to11$fxrate,as.Date(index(hour10to11,0)),mean) # THe TWAP from 10 to 11am NYT.
names(twap10to11)<-"twap"
temp<-merge.xts(fix.prices,twap10to11,join="inner") # this is done to resolve vector length issues.
LHS<-temp$fixing.rate-temp$twap
lhs.h<-xts(rep(0,length(LHS)),index(LHS,0))
lhs.l<-xts(rep(0,length(LHS)),index(LHS,0))
lhs.c<-xts(rep(0,length(LHS)),index(LHS,0))
lhs.v<-xts(rep(0,length(LHS)),index(LHS,0))
lhs.a<-xts(rep(0,length(LHS)),index(LHS,0))
LHS<-merge.xts(LHS,lhs.h,lhs.l,lhs.c,lhs.v,lhs.a)
LHS<-as.quantmod.OHLC(LHS,
col.names = c("Open", "High",
"Low", "Close",
"Volume", "Adjusted"),
name = NULL)
return(LHS)
}
new.LHS<-makeLHS(new.data)
head(new.LHS)
new.df<-na.omit(merge.xts(Op(new.LHS),OpCl(IPC[first.new.date]),join="left"))
names(new.df)<-c("LHS.Open","OpCl.IPC")
new.df<-merge.xts(new.df,OpCl(DOW),join="inner")
new.df<-merge.xts(new.df,OpCl(BSESN),join="inner")
new.df<-merge.xts(new.df,OpCl(GDAXI),join="inner")
new.df<-merge.xts(new.df,OpCl(SSMI),join="inner")
new.df<-merge.xts(new.df,OpCl(TA100),join="inner")
new.df<-merge.xts(new.df,na.omit(Return.calculate(DEXUSAL)),join="inner") # AUDUSD
new.df<-merge.xts(new.df,na.omit(Return.calculate(DEXINUS)),join="inner") # USDINR
new.df<-merge.xts(new.df,na.omit(Return.calculate(DEXBZUS)),join="inner") # USDBRL
new.df<-merge.xts(new.df,na.omit(Return.calculate(DEXCAUS)),join="inner") # USDCAD
new.df<-merge.xts(new.df,na.omit(Return.calculate(DEXUSEU)),join="inner") # EURUSD
new.df<-merge.xts(new.df,na.omit(Return.calculate(DEXJPUS)),join="inner") # USDJPY
new.df<-merge.xts(new.df,na.omit(Return.calculate(DEXMXUS)),join="inner") # USDMXN
new.df<-merge.xts(new.df,na.omit(Return.calculate(DEXKOUS)),join="inner") # USDKRW
head(new.df)
new.model<-lm(train.form,data=new.df)
summary(new.model)
new.actuals<-as.vector(new.df$LHS.Open)
new.fitted<-as.vector(fitted(new.model))
plot(new.actuals,type="l",col="dark grey")
lines(new.fitted,col="blue")
new.signal.perf<-sign(new.fitted)*sign(new.actuals)
plot(density(new.signal.perf),type="l",col="red",ylim=c(0,1.3))
lines(density(train.signal.perf),type="l",col="dark grey")
count(new.signal.perf<0)
63/(139+63)
